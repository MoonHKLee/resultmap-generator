package moonhyuk.lee.resultmap.generator;

import com.google.auto.service.AutoService;
import org.springframework.data.annotation.Id;
import org.springframework.data.relational.core.mapping.Column;
import org.springframework.data.relational.core.mapping.MappedCollection;
import org.springframework.data.relational.core.mapping.Table;

import javax.annotation.processing.*;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.*;
import javax.lang.model.type.DeclaredType;
import javax.tools.Diagnostic;
import javax.tools.FileObject;
import javax.tools.StandardLocation;
import java.io.IOException;
import java.io.Writer;
import java.util.*;

/**
 * 컴파일 타임에 @Table, @Embeddable 클래스를 스캔하여
 * MyBatis <resultMap> XML을 자동 생성하는 Annotation Processor 예시.
 */
@AutoService(Processor.class)
public class MyBatisResultMapProcessor extends AbstractProcessor {

    private Messager messager;

    /**
     * 초기화
     */
    @Override
    public synchronized void init(ProcessingEnvironment processingEnv) {
        super.init(processingEnv);
        this.messager = processingEnv.getMessager();
    }

    /**
     * 어떤 애노테이션을 처리할 것인지 지정.
     */
    @Override
    public Set<String> getSupportedAnnotationTypes() {
        return Set.of(
                Table.class.getCanonicalName(),
                Embeddable.class.getCanonicalName()
        );
    }

    /**
     * 자바 버전
     */
    @Override
    public SourceVersion getSupportedSourceVersion() {
        return SourceVersion.latestSupported();
    }

    /**
     * 애노테이션 처리 로직
     */
    @Override
    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {

        // @Table 달린 클래스들
        Set<? extends Element> tableElements = roundEnv.getElementsAnnotatedWith(Table.class);
        // @Embeddable 달린 클래스들
        Set<? extends Element> embeddableElements = roundEnv.getElementsAnnotatedWith(Embeddable.class);

        if (tableElements.isEmpty() && embeddableElements.isEmpty()) {
            return false;
        }

        // 생성할 Mapper XML 이름
        String namespace = "moonhyuk.lee.myjdbc.AutoGeneratedMapper";
        // 생성
        String xmlContent = generateMapperXml(namespace, tableElements, embeddableElements);

        // 파일 작성
        try {
            FileObject file = processingEnv.getFiler()
                    .createResource(StandardLocation.CLASS_OUTPUT, "", "AutoGeneratedMapper.xml");
            try (Writer writer = file.openWriter()) {
                writer.write(xmlContent);
            }
        } catch (IOException e) {
            error("Failed to write AutoGeneratedMapper.xml: " + e.getMessage());
        }

        return true;
    }

    /**
     * MyBatis Mapper XML 전체 구조 생성
     */
    private String generateMapperXml(String namespace,
                                     Set<? extends Element> tableElements,
                                     Set<? extends Element> embeddableElements) {
        StringBuilder sb = new StringBuilder();

        sb.append("""
                <?xml version="1.0" encoding="UTF-8"?>
                <!DOCTYPE mapper
                        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
                        "https://mybatis.org/dtd/mybatis-3-mapper.dtd">
                """);
        sb.append("<mapper namespace=\"")
          .append(namespace)
          .append("\">\n\n");

        // 1) 먼저 Embeddable 클래스들에 대한 <resultMap> 생성
        for (Element embeddableClass : embeddableElements) {
            sb.append(generateResultMap(embeddableClass, true));
        }

        // 2) @Table 클래스들에 대한 <resultMap> 생성
        for (Element tableClass : tableElements) {
            sb.append(generateResultMap(tableClass, false));
        }

        sb.append("</mapper>\n");
        return sb.toString();
    }

    /**
     * 하나의 클래스에 대한 <resultMap> 생성
     * - isEmbeddable = true -> @Embeddable
     */
    private String generateResultMap(Element classElement, boolean isEmbeddable) {
        // 클래스 정보
        String className = ((TypeElement) classElement).getQualifiedName().toString();
        String simpleName = classElement.getSimpleName().toString();

        // @Table("...") 값 얻기 (Embeddable인 경우 null 가능)
        Table tableAnn = classElement.getAnnotation(Table.class);
        String tableName = (tableAnn != null) ? tableAnn.value() : simpleName;

        // resultMap 아이디
        String resultMapId = simpleName + "ResultMap";

        // 시작
        StringBuilder sb = new StringBuilder();
        sb.append("    <!-- ")
          .append(tableName)
          .append(isEmbeddable ? " (@Embeddable)" : "")
          .append(" -->\n")
          .append("    <resultMap id=\"")
          .append(resultMapId)
          .append("\" type=\"")
          .append(className)
          .append("\">\n");

        // 클래스 내 필드를 순회하며 <id>, <result>, <association>, <collection> 등을 구성
        for (Element field : classElement.getEnclosedElements()) {
            if (field.getKind() != ElementKind.FIELD) {
                continue;
            }
            String fieldName = field.getSimpleName().toString();

            Id idAnn = field.getAnnotation(Id.class);
            Column colAnn = field.getAnnotation(Column.class);
            MappedCollection mappedCollAnn = field.getAnnotation(MappedCollection.class);

            // (A) @Id + @Column
            if (idAnn != null && colAnn != null) {
                sb.append("        <id property=\"")
                  .append(fieldName)
                  .append("\" column=\"")
                  .append(colAnn.value())
                  .append("\"/>\n");
            }
            // (B) 일반 @Column
            else if (colAnn != null) {
                sb.append("        <result property=\"")
                  .append(fieldName)
                  .append("\" column=\"")
                  .append(colAnn.value())
                  .append("\"/>\n");
            }
            // (C) @MappedCollection → <collection>
            else if (mappedCollAnn != null) {
                // Generic 타입 추적(예: List<Order>)
                DeclaredType declaredType = (DeclaredType) field.asType();
                if (!declaredType.getTypeArguments().isEmpty()) {
                    // 첫 번째 제네릭 타입
                    String genericTypeName = declaredType.getTypeArguments().get(0).toString();
                    // 예: "moonhyuk.lee.myjdbc.Order"
                    String nestedSimpleName = genericTypeName.substring(genericTypeName.lastIndexOf('.') + 1);
                    String nestedResultMapId = nestedSimpleName + "ResultMap";

                    sb.append("        <collection property=\"")
                      .append(fieldName)
                      .append("\" resultMap=\"")
                      .append(nestedResultMapId)
                      .append("\"/>\n");
                }
            }
            // (D) 필드 타입이 @Embeddable 인지 확인 → <association resultMap="..." />
            else {
                // 예: Address
                Element fieldTypeElement = processingEnv.getTypeUtils().asElement(field.asType());
                if (fieldTypeElement != null && fieldTypeElement.getAnnotation(Embeddable.class) != null) {
                    String nestedClassName = ((TypeElement) fieldTypeElement).getQualifiedName().toString();
                    String nestedSimpleName = fieldTypeElement.getSimpleName().toString();
                    // 예: "AddressResultMap"
                    String nestedResultMapId = nestedSimpleName + "ResultMap";

                    sb.append("        <association property=\"")
                      .append(fieldName)
                      .append("\" resultMap=\"")
                      .append(nestedResultMapId)
                      .append("\"/>\n");
                }
            }
        }

        sb.append("    </resultMap>\n\n");
        return sb.toString();
    }

    private void error(String msg) {
        messager.printMessage(Diagnostic.Kind.ERROR, msg);
    }
}
